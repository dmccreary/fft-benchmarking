{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to our website.</p>"},{"location":"checklist/","title":"Site Checklist","text":"<ol> <li>Customize the fields in your mkdocs.yml file</li> <li>Configure Google Analytics to use the right site ID</li> <li>Make sure that your .gitignore file includes the <code>site</code> directory</li> <li>Test the build</li> <li>Make sure the Edit button appears</li> <li>Make sure that code color heightening renders correctly</li> <li>run <code>git config advice.addIgnoredFile false</code></li> </ol>"},{"location":"concept-taxonomy/","title":"FFT Benchmarking Course Taxonomy","text":""},{"location":"concept-taxonomy/#taxonomy-categories","title":"Taxonomy Categories","text":"<p>The 200 concepts are organized into 12 pedagogically-sound categories with balanced distribution.</p>"},{"location":"concept-taxonomy/#1-math-mathematical-foundations-20-concepts-10","title":"1. MATH - Mathematical Foundations (20 concepts, 10%)","text":"<p>Abbreviation: MATH Description: Core mathematical concepts underlying FFT and signal processing</p> <p>Concepts: - Complex Numbers, Euler's Formula, Sine Wave Representation - Frequency Domain, Time Domain - Discrete Fourier Transform, Continuous Fourier Transform - Transform Pairs, Linearity Property - Time Shifting, Frequency Shifting, Convolution Theorem - Parseval's Theorem, Symmetry Properties - Magnitude Spectrum, Phase Spectrum - Rectangular Form, Polar Form - Sampling Theorem, Nyquist Frequency</p>"},{"location":"concept-taxonomy/#2-fft-fft-algorithm-implementation-25-concepts-125","title":"2. FFT - FFT Algorithm &amp; Implementation (25 concepts, 12.5%)","text":"<p>Abbreviation: FFT Description: Fast Fourier Transform algorithms, variants, and computational techniques</p> <p>Concepts: - Fast Fourier Transform, Cooley-Tukey Algorithm - Divide And Conquer, Butterfly Operation - Radix-2 FFT, Radix-4 FFT, Radix-8 FFT, Mixed Radix FFT - Decimation In Time, Decimation In Frequency - Bit Reversal Permutation, Twiddle Factors - In-Place Computation, Computational Complexity - FFT Size Selection, Power Of Two Constraint - Inverse FFT, FFT Scaling - Real FFT, Complex FFT - Half-Spectrum Property, Zero Padding - Frequency Resolution, Time Resolution Tradeoff - Circular Convolution</p>"},{"location":"concept-taxonomy/#3-sig-signal-processing-25-concepts-125","title":"3. SIG - Signal Processing (25 concepts, 12.5%)","text":"<p>Abbreviation: SIG Description: Digital signal processing concepts, windowing, and frame-based analysis</p> <p>Concepts: - Digital Signal Processing - Analog To Digital Conversion, Digital To Analog Conversion - Sample Rate, Quantization, Bit Depth - Dynamic Range, Signal To Noise Ratio - Windowing Functions (Rectangular, Hanning, Hamming, Blackman, Kaiser) - Window Sidelobe Levels, Spectral Leakage, Scalloping Loss - Overlap Add Method, Overlap Save Method - Frame Size, Hop Size - Frequency Bins, Bin Width - Spectrum Analysis, Spectrogram</p>"},{"location":"concept-taxonomy/#4-arm-arm-architecture-dsp-hardware-30-concepts-15","title":"4. ARM - ARM Architecture &amp; DSP Hardware (30 concepts, 15%)","text":"<p>Abbreviation: ARM Description: ARM Cortex-M processors, DSP instructions, and hardware features</p> <p>Concepts: - ARM Cortex M Series, Cortex M4 Processor, Cortex M33 Processor - Instruction Set Architecture, Thumb Instructions - DSP Extension Instructions, Single Instruction Multiple Data - MAC Instructions, Saturating Arithmetic - Floating Point Unit, Single Precision Float, Double Precision Float - Hardware Floating Point, Software Floating Point - FPU Register File, Pipeline Architecture - Instruction Pipeline, Branch Prediction - Interrupt Handling, Exception Handling - Memory Mapped IO, Peripheral Access - Clock Configuration, Clock Cycles - Instruction Cycle Count, Wait States - Flash Memory Access, RAM Access Patterns - Direct Memory Access, DMA Channels</p>"},{"location":"concept-taxonomy/#5-mem-memory-management-optimization-25-concepts-125","title":"5. MEM - Memory Management &amp; Optimization (25 concepts, 12.5%)","text":"<p>Abbreviation: MEM Description: Memory architecture, cache, buffers, and data layout strategies</p> <p>Concepts: - Cache Memory, Cache Hit Rate, Cache Miss Penalty - Data Cache, Instruction Cache, Cache Line Size - Memory Alignment, Aligned Data Access, Unaligned Data Access - Memory Bandwidth, Memory Latency - Stack Memory, Heap Memory - Static Memory Allocation, Dynamic Memory Allocation - Buffer Management, Double Buffering - Ping Pong Buffers, Circular Buffers - Memory Copy Operations, Data Layout - Structure Packing, Array Of Structures - Structure Of Arrays, Memory Fragmentation</p>"},{"location":"concept-taxonomy/#6-fxp-fixed-point-arithmetic-18-concepts-9","title":"6. FXP - Fixed-Point Arithmetic (18 concepts, 9%)","text":"<p>Abbreviation: FXP Description: Fixed-point number representation and arithmetic operations</p> <p>Concepts: - Fixed Point Numbers, Q Format Notation - Integer Representation, Fractional Representation - Scaling Factor - Fixed Point Multiplication, Fixed Point Division, Fixed Point Addition - Overflow Detection, Saturation Handling - Rounding Modes, Truncation Error - Quantization Noise, Dynamic Range Management - Precision Analysis, Bit Width Selection - Sign Extension, Fixed To Float Conversion</p>"},{"location":"concept-taxonomy/#7-bench-benchmarking-testing-30-concepts-15","title":"7. BENCH - Benchmarking &amp; Testing (30 concepts, 15%)","text":"<p>Abbreviation: BENCH Description: Performance measurement, profiling, statistical analysis, and test design</p> <p>Concepts: - Performance Metrics, Execution Time - Clock Cycle Measurement, System Timer - High Resolution Timer, Timestamp Counter - Profiling Tools, Code Profiling - Function Profiling, Instruction Profiling - Statistical Analysis, Mean Execution Time - Standard Deviation, Variance Analysis - Outlier Detection, Confidence Intervals - Benchmark Repeatability, Test Case Design - Input Signal Generation - Sine Wave Test Signal, Chirp Signal - White Noise Signal, Impulse Response - Frequency Sweep, Amplitude Scaling - Baseline Measurement, Comparative Analysis - Performance Regression, Benchmark Automation - Test Harness Design</p>"},{"location":"concept-taxonomy/#8-lib-fft-libraries-integration-20-concepts-10","title":"8. LIB - FFT Libraries &amp; Integration (20 concepts, 10%)","text":"<p>Abbreviation: LIB Description: FFT libraries, APIs, licensing, and integration techniques</p> <p>Concepts: - CMSIS DSP Library, FFTW Library, Kiss FFT - FFT Library Licensing - Open Source Libraries, Proprietary Libraries - Library API Design, Function Call Overhead - Initialization Functions, Configuration Parameters - Library Documentation, Example Code - GitHub Repositories, Version Control - Library Integration, Header Files - Linking Libraries, Static Linking - Dynamic Linking, Library Dependencies</p>"},{"location":"concept-taxonomy/#9-opt-optimization-techniques-7-concepts-35","title":"9. OPT - Optimization Techniques (7 concepts, 3.5%)","text":"<p>Abbreviation: OPT Description: Compiler and code optimization strategies</p> <p>Concepts: - Compiler Optimization Levels - Loop Unrolling, Function Inlining - Code Size Optimization, Speed Optimization - Constant Propagation, Dead Code Elimination</p>"},{"location":"concept-taxonomy/#10-prog-programming-development-15-concepts-75","title":"10. PROG - Programming &amp; Development (15 concepts, 7.5%)","text":"<p>Abbreviation: PROG Description: Programming languages, tools, and development practices (Optional Extension)</p> <p>Concepts: - C Programming Language, Python For Analysis - NumPy Library, SciPy FFT Functions - Matplotlib Visualization - Assembly Language, Reading Assembly Code - Hand Coded Optimization, Intrinsic Functions - Volatile Keyword, Register Variables - Pointer Arithmetic, Makefile Build System - Cross Compilation, Debugging Embedded Code</p>"},{"location":"concept-taxonomy/#11-app-applications-context-10-concepts-5","title":"11. APP - Applications &amp; Context (10 concepts, 5%)","text":"<p>Abbreviation: APP Description: Real-world applications and hardware platforms (Optional Extension)</p> <p>Concepts: - Audio Signal Processing, Speech Compression - Frequency Analysis, Real Time Processing - Latency Requirements - Raspberry Pi Pico, RP2350 Microcontroller - ADC Configuration, DAC Configuration - Audio Sampling Rates</p>"},{"location":"concept-taxonomy/#12-doc-documentation-workflows-0-concepts-extension-available","title":"12. DOC - Documentation &amp; Workflows (0 concepts - Extension Available)","text":"<p>Abbreviation: DOC Description: Project documentation, collaboration tools, and workflows</p> <p>Note: Core 200 concepts focus on technical content. Documentation concepts can be added as extensions.</p>"},{"location":"concept-taxonomy/#distribution-summary","title":"Distribution Summary","text":"Category Code Count Percentage Status Math MATH 20 10.0% \u2713 Under 30% FFT FFT 25 12.5% \u2713 Under 30% Signal SIG 25 12.5% \u2713 Under 30% ARM ARM 30 15.0% \u2713 Under 30% Memory MEM 25 12.5% \u2713 Under 30% Fixed FXP 18 9.0% \u2713 Under 30% Bench BENCH 30 15.0% \u2713 Under 30% Library LIB 20 10.0% \u2713 Under 30% Optimize OPT 7 3.5% \u2713 Under 30% Total 200 100% \u2713 Balanced"},{"location":"concept-taxonomy/#category-relationships","title":"Category Relationships","text":"<p>Mathematical Foundation: MATH \u2192 FFT \u2192 SIG Hardware Platform: ARM \u2192 MEM Numeric Precision: FXP (alternative to hardware float) Performance: BENCH \u2192 OPT Software Integration: LIB \u2192 PROG Real Applications: APP</p>"},{"location":"concept-taxonomy/#pedagogical-flow","title":"Pedagogical Flow","text":"<ol> <li>Weeks 1-2: MATH foundations</li> <li>Weeks 3-4: FFT + SIG concepts</li> <li>Weeks 5-6: ARM + MEM hardware</li> <li>Week 7: FXP arithmetic + BENCH methodology</li> <li>Week 8: LIB integration + OPT techniques</li> <li>Weeks 9-10: PROG + APP capstone project</li> </ol>"},{"location":"concept-taxonomy/#quality-metrics","title":"Quality Metrics","text":"<p>\u2713 12 categories (target: ~12) \u2713 All categories &lt; 30% of total (largest: ARM and BENCH at 15%) \u2713 Balanced distribution across theoretical and practical domains \u2713 Clear abbreviations (3-5 letters) \u2713 Pedagogically coherent category groupings</p>"},{"location":"contact/","title":"Contact","text":"<p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"course-concepts-v1/","title":"FFT Benchmarking Course: 200 Core Concepts","text":""},{"location":"course-concepts-v1/#mathematical-foundations-20-concepts","title":"Mathematical Foundations (20 concepts)","text":"<ol> <li>Complex Numbers</li> <li>Euler's Formula</li> <li>Sine Wave Representation</li> <li>Frequency Domain</li> <li>Time Domain</li> <li>Discrete Fourier Transform</li> <li>Continuous Fourier Transform</li> <li>Transform Pairs</li> <li>Linearity Property</li> <li>Time Shifting</li> <li>Frequency Shifting</li> <li>Convolution Theorem</li> <li>Parseval's Theorem</li> <li>Symmetry Properties</li> <li>Magnitude Spectrum</li> <li>Phase Spectrum</li> <li>Rectangular Form</li> <li>Polar Form</li> <li>Sampling Theorem</li> <li>Nyquist Frequency</li> </ol>"},{"location":"course-concepts-v1/#fft-algorithm-fundamentals-25-concepts","title":"FFT Algorithm Fundamentals (25 concepts)","text":"<ol> <li>Fast Fourier Transform</li> <li>Cooley-Tukey Algorithm</li> <li>Divide And Conquer</li> <li>Butterfly Operation</li> <li>Radix-2 FFT</li> <li>Radix-4 FFT</li> <li>Radix-8 FFT</li> <li>Mixed Radix FFT</li> <li>Decimation In Time</li> <li>Decimation In Frequency</li> <li>Bit Reversal Permutation</li> <li>Twiddle Factors</li> <li>In-Place Computation</li> <li>Computational Complexity</li> <li>FFT Size Selection</li> <li>Power Of Two Constraint</li> <li>Inverse FFT</li> <li>FFT Scaling</li> <li>Real FFT</li> <li>Complex FFT</li> <li>Half-Spectrum Property</li> <li>Zero Padding</li> <li>Frequency Resolution</li> <li>Time Resolution Tradeoff</li> <li>Circular Convolution</li> </ol>"},{"location":"course-concepts-v1/#signal-processing-concepts-25-concepts","title":"Signal Processing Concepts (25 concepts)","text":"<ol> <li>Digital Signal Processing</li> <li>Analog To Digital Conversion</li> <li>Digital To Analog Conversion</li> <li>Sample Rate</li> <li>Quantization</li> <li>Bit Depth</li> <li>Dynamic Range</li> <li>Signal To Noise Ratio</li> <li>Windowing Functions</li> <li>Rectangular Window</li> <li>Hanning Window</li> <li>Hamming Window</li> <li>Blackman Window</li> <li>Kaiser Window</li> <li>Window Sidelobe Levels</li> <li>Spectral Leakage</li> <li>Scalloping Loss</li> <li>Overlap Add Method</li> <li>Overlap Save Method</li> <li>Frame Size</li> <li>Hop Size</li> <li>Frequency Bins</li> <li>Bin Width</li> <li>Spectrum Analysis</li> <li>Spectrogram</li> </ol>"},{"location":"course-concepts-v1/#arm-architecture-dsp-30-concepts","title":"ARM Architecture &amp; DSP (30 concepts)","text":"<ol> <li>ARM Cortex M Series</li> <li>Cortex M4 Processor</li> <li>Cortex M33 Processor</li> <li>Instruction Set Architecture</li> <li>Thumb Instructions</li> <li>DSP Extension Instructions</li> <li>Single Instruction Multiple Data</li> <li>MAC Instructions</li> <li>Saturating Arithmetic</li> <li>Floating Point Unit</li> <li>Single Precision Float</li> <li>Double Precision Float</li> <li>Hardware Floating Point</li> <li>Software Floating Point</li> <li>FPU Register File</li> <li>Pipeline Architecture</li> <li>Instruction Pipeline</li> <li>Branch Prediction</li> <li>Interrupt Handling</li> <li>Exception Handling</li> <li>Memory Mapped IO</li> <li>Peripheral Access</li> <li>Clock Configuration</li> <li>Clock Cycles</li> <li>Instruction Cycle Count</li> <li>Wait States</li> <li>Flash Memory Access</li> <li>RAM Access Patterns</li> <li>Direct Memory Access</li> <li>DMA Channels</li> </ol>"},{"location":"course-concepts-v1/#memory-performance-25-concepts","title":"Memory &amp; Performance (25 concepts)","text":"<ol> <li>Cache Memory</li> <li>Cache Hit Rate</li> <li>Cache Miss Penalty</li> <li>Data Cache</li> <li>Instruction Cache</li> <li>Cache Line Size</li> <li>Memory Alignment</li> <li>Aligned Data Access</li> <li>Unaligned Data Access</li> <li>Memory Bandwidth</li> <li>Memory Latency</li> <li>Stack Memory</li> <li>Heap Memory</li> <li>Static Memory Allocation</li> <li>Dynamic Memory Allocation</li> <li>Buffer Management</li> <li>Double Buffering</li> <li>Ping Pong Buffers</li> <li>Circular Buffers</li> <li>Memory Copy Operations</li> <li>Data Layout</li> <li>Structure Packing</li> <li>Array Of Structures</li> <li>Structure Of Arrays</li> <li>Memory Fragmentation</li> </ol>"},{"location":"course-concepts-v1/#fixed-point-arithmetic-18-concepts","title":"Fixed-Point Arithmetic (18 concepts)","text":"<ol> <li>Fixed Point Numbers</li> <li>Q Format Notation</li> <li>Integer Representation</li> <li>Fractional Representation</li> <li>Scaling Factor</li> <li>Fixed Point Multiplication</li> <li>Fixed Point Division</li> <li>Fixed Point Addition</li> <li>Overflow Detection</li> <li>Saturation Handling</li> <li>Rounding Modes</li> <li>Truncation Error</li> <li>Quantization Noise</li> <li>Dynamic Range Management</li> <li>Precision Analysis</li> <li>Bit Width Selection</li> <li>Sign Extension</li> <li>Fixed To Float Conversion</li> </ol>"},{"location":"course-concepts-v1/#benchmarking-methodology-30-concepts","title":"Benchmarking Methodology (30 concepts)","text":"<ol> <li>Performance Metrics</li> <li>Execution Time</li> <li>Clock Cycle Measurement</li> <li>System Timer</li> <li>High Resolution Timer</li> <li>Timestamp Counter</li> <li>Profiling Tools</li> <li>Code Profiling</li> <li>Function Profiling</li> <li>Instruction Profiling</li> <li>Statistical Analysis</li> <li>Mean Execution Time</li> <li>Standard Deviation</li> <li>Variance Analysis</li> <li>Outlier Detection</li> <li>Confidence Intervals</li> <li>Benchmark Repeatability</li> <li>Test Case Design</li> <li>Input Signal Generation</li> <li>Sine Wave Test Signal</li> <li>Chirp Signal</li> <li>White Noise Signal</li> <li>Impulse Response</li> <li>Frequency Sweep</li> <li>Amplitude Scaling</li> <li>Baseline Measurement</li> <li>Comparative Analysis</li> <li>Performance Regression</li> <li>Benchmark Automation</li> <li>Test Harness Design</li> </ol>"},{"location":"course-concepts-v1/#fft-libraries-tools-20-concepts","title":"FFT Libraries &amp; Tools (20 concepts)","text":"<ol> <li>CMSIS DSP Library</li> <li>FFTW Library</li> <li>Kiss FFT</li> <li>FFT Library Licensing</li> <li>Open Source Libraries</li> <li>Proprietary Libraries</li> <li>Library API Design</li> <li>Function Call Overhead</li> <li>Initialization Functions</li> <li>Configuration Parameters</li> <li>Library Documentation</li> <li>Example Code</li> <li>GitHub Repositories</li> <li>Version Control</li> <li>Library Integration</li> <li>Header Files</li> <li>Linking Libraries</li> <li>Static Linking</li> <li>Dynamic Linking</li> <li>Library Dependencies</li> </ol>"},{"location":"course-concepts-v1/#optimization-techniques-15-concepts","title":"Optimization Techniques (15 concepts)","text":"<ol> <li>Compiler Optimization Levels</li> <li>Loop Unrolling</li> <li>Function Inlining</li> <li>Code Size Optimization</li> <li>Speed Optimization</li> <li>Constant Propagation</li> <li>Dead Code Elimination</li> </ol>"},{"location":"course-concepts-v1/#development-programming-15-concepts-optional-extensions","title":"Development &amp; Programming (15 concepts - Optional Extensions)","text":"<ol> <li>C Programming Language</li> <li>Python For Analysis</li> <li>NumPy Library</li> <li>SciPy FFT Functions</li> <li>Matplotlib Visualization</li> <li>Assembly Language</li> <li>Reading Assembly Code</li> <li>Hand Coded Optimization</li> <li>Intrinsic Functions</li> <li>Volatile Keyword</li> <li>Register Variables</li> <li>Pointer Arithmetic</li> <li>Makefile Build System</li> <li>Cross Compilation</li> <li>Debugging Embedded Code</li> </ol>"},{"location":"course-concepts-v1/#applications-context-10-concepts-optional-extensions","title":"Applications &amp; Context (10 concepts - Optional Extensions)","text":"<ol> <li>Audio Signal Processing</li> <li>Speech Compression</li> <li>Frequency Analysis</li> <li>Real Time Processing</li> <li>Latency Requirements</li> <li>Raspberry Pi Pico</li> <li>RP2350 Microcontroller</li> <li>ADC Configuration</li> <li>DAC Configuration</li> <li>Audio Sampling Rates</li> </ol>"},{"location":"course-description/","title":"Course Description","text":"<p>Title: Benchmarking FFT Course Length: 10-weeks or independent study Audience: College juniors or seniors with a curiosity in signal processing</p>"},{"location":"course-description/#summary","title":"Summary","text":"<p>This course covers the process of doing objective benchmarking of the FFT algorithm on both microcontrollers as well as standard CPUs.  We provide a high-level background to the FFT algorithm and why it is critical in modern real-time signal processing.  We then describe a framework for benchmarking FFT algorithm performance on different data sets. We conclude with methods for presenting the results of FFT benchmarks.</p>"},{"location":"course-description/#why-this-course","title":"Why This Course","text":"<p>In the past, only expensive digital signal processing (DSP) chips did real-time FFTs.  However, in 2001 companies like ARM started to add DSP instructions to their low cost CPUs and microcontrollers.  For example in 2010 the ARM Cortex M4 added instructions to specifically perform DSP functions.  In August 2024 the Raspberry Pi Foundation release the Raspberry Pi Pico 2 built around the ARM Cortex-M33 which had many DSP and floating point functions.  For $6 this made real-time FFT for signal processing affordable for many products.</p> <p>However, many programmers were not aware of these DSP functions and the impact faster signal processing has on applications.  Many FFT libraries still used older instruction sets.  The root cause was that many developers were unaware of the signal processing power they had but were not using.</p> <p>This course attempts to guide students from the basics of what the FFT algorithm does and how DSP-specific hardware can accelerate signal processing products.  </p> <p>We study the process of not only comparing different FFT implementations, but we look at the tradeoffs of different FFT parameters such as FFT size, integer vs. floating point and other choices that impact FFT processing speed.</p>"},{"location":"course-description/#content","title":"Content","text":"<p>Fourier Transforms Math Foundations Programming Background FFT History FFT Timeline FFT Basics FFT Butterfly FFT and IFFT FFT Performance FFT Benchmarking FFT Parameters FFT Size Integer vs Floating Point Preprocessing Signals Post Processing of Signals Programming Languages C Language Python Libraries Machine Language Reading Assembly Languages DSP Functions FFT Libraries GitHub Repositories FFT Licenses Benchmarking Frameworks Performance Comparisons Presenting Results Performance Charts</p>"},{"location":"course-description/#outcomes","title":"Outcomes","text":"<p>The Bloom Taxonomy gives us a way to categorize outcomes starting with memorization of terms through the ability to create new artifacts.</p> <p>After this course a student will</p>"},{"location":"course-description/#remember","title":"Remember","text":"<ul> <li>Recall the key properties of the Fast Fourier Transform (FFT) algorithm</li> <li>List the DSP instructions available in ARM Cortex-M33 and M4 processors</li> <li>Identify common FFT libraries and their licensing requirements</li> <li>Define terminology such as FFT size, butterfly operations, and preprocessing</li> <li>Name the tradeoffs between integer and floating-point FFT implementations</li> </ul>"},{"location":"course-description/#understand","title":"Understand","text":"<ul> <li>Explain how the FFT algorithm transforms time-domain signals to frequency domain</li> <li>Describe the relationship between FFT size and computational complexity</li> <li>Summarize the historical development of DSP hardware acceleration</li> <li>Interpret assembly language output to understand low-level FFT operations</li> <li>Clarify why certain hardware features improve FFT performance</li> </ul>"},{"location":"course-description/#apply","title":"Apply","text":"<ul> <li>Implement FFT benchmarks using provided frameworks on microcontrollers</li> <li>Use appropriate FFT libraries in C and Python for signal processing tasks</li> <li>Configure FFT parameters (size, precision, windowing) for specific applications</li> <li>Execute performance measurements across different hardware platforms</li> <li>Apply preprocessing and post-processing techniques to improve FFT results</li> </ul>"},{"location":"course-description/#analyze","title":"Analyze","text":"<ul> <li>Compare the performance characteristics of different FFT implementations</li> <li>Examine assembly code to identify optimization opportunities</li> <li>Differentiate between factors affecting FFT speed (hardware, software, parameters)</li> <li>Investigate the relationship between FFT parameters and execution time</li> <li>Break down complex benchmarking results to identify performance bottlenecks</li> </ul>"},{"location":"course-description/#evaluate","title":"Evaluate","text":"<ul> <li>Assess which FFT library is most appropriate for a given application</li> <li>Critique benchmarking methodologies for validity and completeness</li> <li>Judge the quality and accuracy of FFT performance claims</li> <li>Determine optimal FFT parameters based on application constraints</li> <li>Justify hardware and software choices for real-time signal processing systems</li> </ul>"},{"location":"course-description/#create","title":"Create","text":"<ul> <li>Design a comprehensive benchmarking framework for FFT evaluation</li> <li>Develop custom visualizations to present FFT performance comparisons</li> <li>Produce a capstone project documenting FFT performance across platforms</li> <li>Generate recommendations for FFT implementation strategies</li> <li>Construct a complete analysis report with methodology, results, and conclusions</li> </ul>"},{"location":"course-description/#grading","title":"Grading","text":"<p>The grading will be as follows:</p> <ol> <li>25% homework</li> <li>25% midterm</li> <li>25% capstone project</li> <li>25% final exam</li> </ol>"},{"location":"glossary/","title":"Glossary of Terms","text":""},{"location":"glossary/#iso-definition","title":"ISO Definition","text":"<p>A term definition is considered to be consistent with ISO metadata registry guideline 11179 if it meets the following criteria:</p> <ol> <li>Precise</li> <li>Concise</li> <li>Distinct</li> <li>Non-circular</li> <li>Unencumbered with business rules</li> </ol>"},{"location":"glossary/#term","title":"Term","text":"<p>This is the definition of the term.</p>"},{"location":"how-we-built-this-site/","title":"How We Built This Site","text":"<p>This page describes how we built this website and some of  the rationale behind why we made various design choices.</p>"},{"location":"how-we-built-this-site/#python","title":"Python","text":"<p>MicroSims are about how we use generative AI to create animations and simulations.  The language of AI is Python.  So we wanted to create a site that could be easily understood by Python developers.</p>"},{"location":"how-we-built-this-site/#mkdocs-vs-docusaurus","title":"Mkdocs vs. Docusaurus","text":"<p>There are two main tools used by Python developers to write documentation: Mkdocs and Docusaurus.  Mkdocs is easier to use and more popular than Docusaurus. Docusaurus is also optimized for single-page applications. Mkdocs also has an extensive library of themes and plugins. None of us are experts in JavaScript or React. Based on our ChatGPT Analysis of the Tradeoffs we chose mkdocs for this site management.</p>"},{"location":"how-we-built-this-site/#github-and-github-pages","title":"GitHub and GitHub Pages","text":"<p>GitHub is a logical choice to store our  site source code and documentation.  GitHub also has a Custom GitHub Action that does auto-deployment if any files on the site change. We don't currently have this action enabled, but other teams can use this feature if they don't have the ability to do a local build with mkdocs.</p> <p>GitHub also has Issues,  Projects and releases that we can use to manage our bugs and tasks.</p> <p>The best practice for low-cost websites that have public-only content is GitHub Pages. Mkdocs has a command (<code>mkdocs gh-deploy</code>) that does deployment directly to GitHub Pages.  This was an easy choice to make.</p>"},{"location":"how-we-built-this-site/#github-clone","title":"GitHub Clone","text":"<p>If you would like to clone this repository, here are the commands:</p> <pre><code>mkdir projects\ncd projects\ngit clone https://github.com/dmccreary/microsims\n</code></pre>"},{"location":"how-we-built-this-site/#after-changes","title":"After Changes","text":"<p>After you make local changes you must do the following:</p> <pre><code># add the new files to a a local commit transaction\ngit add FILES\n# Execute the a local commit with a message about what and why you are doing the commit\ngit commit -m \"comment\"\n# Update the central GitHub repository\ngit push\n</code></pre>"},{"location":"how-we-built-this-site/#material-theme","title":"Material Theme","text":"<p>We had several options when picking a mkdocs theme:</p> <ol> <li>Mkdocs default</li> <li>Readthedocs</li> <li>Third-Party Themes See Ranking</li> </ol> <p>The Material Theme had 16K stars.  No other theme had over a few hundred. This was also an easy design decision.</p> <p>One key criterial was the social Open Graph tags so that when our users post a link to a simulation, the image of the simulation is included in the link.  Since Material supported this, we used the Material theme. You can see our ChatGPT Design Decision Analysis if you want to check our decision process.</p>"},{"location":"how-we-built-this-site/#enable-edit-icon","title":"Enable Edit Icon","text":"<p>To enable the Edit icon on all pages, you must add the edit_uri and the content.action.edit under the theme features area.</p> <pre><code>edit_uri: edit/master/docs/\n</code></pre> <pre><code>    theme:\n        features:\n            - content.action.edit\n</code></pre>"},{"location":"how-we-built-this-site/#conda-vs-venv","title":"Conda vs VENV","text":"<p>There are two choices for virtual environments.  We can use the native Python venv or use Conda.  venv is simle but is only designed for pure Python projects.  We imagine that this site could use JavaScript and other langauges in the future, so we picked Conda. There is nothing on this microsite that prevents you from using one or the other.  See the ChatGPT Analysis Here.</p> <p>Here is the conda script that we ran to create a new mkdocs environment that also supports the material social imaging libraries.</p> <pre><code>conda deactivate\nconda create -n mkdocs python=3\nconda activate mkdocs\npip install mkdocs \"mkdocs-material[imaging]\"\n</code></pre>"},{"location":"how-we-built-this-site/#mkdocs-commands","title":"Mkdocs Commands","text":"<p>There are three simple mkdoc commands we use.</p>"},{"location":"how-we-built-this-site/#local-build","title":"Local Build","text":"<pre><code>mkdocs build\n</code></pre> <p>This builds your website in a folder called <code>site</code>.  Use this to test that the mkdocs.yml site is working and does not have any errors.</p>"},{"location":"how-we-built-this-site/#run-a-local-server","title":"Run a Local Server","text":"<pre><code>mkdocs serve\n</code></pre> <p>This runs a server on <code>http://localhost:8000</code>. Use this to test the display formatting locally before you push your code up to the GitHub repo.</p> <pre><code>mkdoc gh-deploy\n</code></pre> <p>This pushes everything up to the GitHub Pages site. Note that it does not commit your code to GitHub.</p>"},{"location":"how-we-built-this-site/#mkdocs-material-social-tags","title":"Mkdocs Material Social Tags","text":"<p>We are using the Material Social tags.  This is a work in progress!</p> <p>Here is what we have learned.</p> <ol> <li>There are extensive image processing libraries that can't be installed with just pip.  You will need to run a tool like brew on the Mac to get the libraries installed.</li> <li>Even after <code>brew</code> installs the libraries, you have to get your environment to find the libraries.  The only way I could get that to work was to set up a local UNIX environment variable.</li> </ol> <p>Here is the brew command that I ran:</p> <pre><code>brew install cairo freetype libffi libjpeg libpng zlib\n</code></pre> <p>I then had to add the following to my ~/.zshrc file:</p> <pre><code>export DYLD_FALLBACK_LIBRARY_PATH=/opt/homebrew/lib\n</code></pre> <p>Note that I am running on a Mac with Apple silicon.  This means that the image libraries that brew downloads must be specific to the Mac Arm instruction set.</p> <ul> <li>Cover images for blog post #4364</li> <li>Discussion on overriding the Social Card Image</li> </ul>"},{"location":"learning-graph-README/","title":"FFT Benchmarking Learning Graph","text":""},{"location":"learning-graph-README/#overview","title":"Overview","text":"<p>This directory contains a complete learning graph for the FFT Benchmarking course, generated using the Learning Graph Generator methodology. The graph represents 200 interconnected concepts organized into a pedagogically sound structure.</p>"},{"location":"learning-graph-README/#generated-files","title":"Generated Files","text":""},{"location":"learning-graph-README/#core-outputs","title":"Core Outputs","text":"<ol> <li>course-concepts-v1.md - List of 200 concept labels</li> <li>Organized by taxonomy category</li> <li>Title Case format (max 32 characters)</li> <li> <p>Covers mathematical foundations through practical implementation</p> </li> <li> <p>concept-dependencies.csv - Dependency graph in CSV format</p> </li> <li>Columns: ConceptID, ConceptLabel, Dependencies, TaxonomyID</li> <li>Dependencies use pipe-delimited format (e.g., \"1|4|5\")</li> <li>Valid DAG structure (no cycles)</li> <li> <p>Ready for import into spreadsheet tools</p> </li> <li> <p>learning-graph.json - JSON format for visualization tools</p> </li> <li>Nodes: 200 concepts with ID, label, and taxonomy</li> <li>Links: 229 directed edges representing prerequisites</li> <li>Metadata: Course title, description, taxonomy definitions</li> <li>Compatible with D3.js, vis.js, and other graph visualization libraries</li> </ol>"},{"location":"learning-graph-README/#analysis-documentation","title":"Analysis &amp; Documentation","text":"<ol> <li>quality-assessment.md - Course content depth analysis</li> <li>Validates course has sufficient depth for 200 concepts</li> <li>Compares against similar courses</li> <li> <p>Identifies content gaps and strengths</p> </li> <li> <p>quality-metrics.md - Graph structure validation</p> </li> <li>\u2713 DAG validation (no cycles detected)</li> <li>Foundational concepts: 10 entry points</li> <li>Indegree distribution analysis</li> <li>Longest dependency chains: 7 levels</li> <li> <p>Connectivity: 94% in main component</p> </li> <li> <p>concept-taxonomy.md - Category organization</p> </li> <li>9 balanced categories (3.5% - 15% each)</li> <li>All categories under 30% threshold \u2713</li> <li>Pedagogical flow recommendations</li> <li> <p>Clear 3-5 letter abbreviations</p> </li> <li> <p>taxonomy-distribution.md - Statistical breakdown</p> </li> <li>Detailed concept listing by category</li> <li>Visual distribution table</li> <li>Balance verification</li> </ol>"},{"location":"learning-graph-README/#taxonomy-categories","title":"Taxonomy Categories","text":"Code Name Concepts % MATH Mathematical Foundations 20 10.0% FFT FFT Algorithm &amp; Implementation 25 12.5% SIG Signal Processing 25 12.5% ARM ARM Architecture &amp; DSP Hardware 30 15.0% MEM Memory Management &amp; Optimization 25 12.5% FXP Fixed-Point Arithmetic 18 9.0% BENCH Benchmarking &amp; Testing 30 15.0% LIB FFT Libraries &amp; Integration 20 10.0% OPT Optimization Techniques 7 3.5%"},{"location":"learning-graph-README/#quality-metrics-summary","title":"Quality Metrics Summary","text":"<p>\u2713 DAG Structure: Valid - no cycles \u2713 Balanced Distribution: All categories &lt; 30% \u2713 Foundational Base: 10 entry-point concepts \u2713 Manageable Complexity: Avg 1.15 dependencies per concept \u2713 Clear Progression: Max chain length of 7 levels \u2713 High Connectivity: 94% in main component</p>"},{"location":"learning-graph-README/#usage","title":"Usage","text":""},{"location":"learning-graph-README/#for-course-development","title":"For Course Development","text":"<ol> <li>Use concept-dependencies.csv to plan weekly modules</li> <li>Follow dependency chains to order lessons</li> <li>Start with foundational concepts (zero dependencies)</li> <li>Build assessments based on taxonomy categories</li> </ol>"},{"location":"learning-graph-README/#for-visualization","title":"For Visualization","text":"<ol> <li>Load learning-graph.json into visualization tools:</li> <li>D3.js force-directed graph</li> <li>vis.js network diagram</li> <li>Graphviz DOT format</li> <li>Neo4j graph database</li> </ol>"},{"location":"learning-graph-README/#for-analysis","title":"For Analysis","text":"<ol> <li>Run analyze-graph.py to validate structure</li> <li>Run taxonomy-distribution.py for category stats</li> <li>Run convert-to-json.py to regenerate JSON</li> </ol>"},{"location":"learning-graph-README/#python-utilities","title":"Python Utilities","text":"<p>Three Python scripts are provided in the repository root:</p> <pre><code># Validate graph structure\npython3 analyze-graph.py\n\n# Generate taxonomy distribution report\npython3 taxonomy-distribution.py &gt; docs/taxonomy-distribution.md\n\n# Convert CSV to JSON\npython3 convert-to-json.py\n</code></pre>"},{"location":"learning-graph-README/#pedagogical-recommendations","title":"Pedagogical Recommendations","text":""},{"location":"learning-graph-README/#10-week-course-structure","title":"10-Week Course Structure","text":"<p>Weeks 1-2: MATH foundations (20 concepts) Weeks 3-4: FFT + SIG (50 concepts) Weeks 5-6: ARM + MEM (55 concepts) Week 7: FXP + BENCH part 1 (33 concepts) Week 8: BENCH part 2 + LIB (27 concepts) Weeks 9-10: OPT + Capstone project (15 concepts)</p>"},{"location":"learning-graph-README/#learning-paths","title":"Learning Paths","text":"<p>Mathematics-First Path: MATH \u2192 FFT \u2192 SIG \u2192 BENCH Hardware-First Path: ARM \u2192 MEM \u2192 FXP \u2192 BENCH Practical-First Path: LIB \u2192 SIG \u2192 BENCH \u2192 FFT</p>"},{"location":"learning-graph-README/#visualization-ideas","title":"Visualization Ideas","text":"<ol> <li>Interactive Network Graph</li> <li>Color-code by taxonomy</li> <li>Show dependencies on hover</li> <li>Filter by category</li> <li> <p>Highlight learning paths</p> </li> <li> <p>Dependency Matrix</p> </li> <li>Heatmap showing concept relationships</li> <li>Identify prerequisite clusters</li> <li> <p>Spot isolated concepts</p> </li> <li> <p>Learning Path Timeline</p> </li> <li>Linear visualization by dependency level</li> <li>Show parallel learning opportunities</li> <li> <p>Estimate time per concept</p> </li> <li> <p>Category Distribution Sunburst</p> </li> <li>Hierarchical view</li> <li>Show proportions visually</li> <li>Drill down into categories</li> </ol>"},{"location":"learning-graph-README/#next-steps","title":"Next Steps","text":"<ol> <li>\u2713 Generate learning graph (complete)</li> <li>\u2610 Create interactive visualization</li> <li>\u2610 Develop detailed lesson plans per concept</li> <li>\u2610 Design assessments aligned with Bloom's taxonomy</li> <li>\u2610 Build capstone project integrating concepts</li> <li>\u2610 Create MkDocs pages for each concept</li> </ol>"},{"location":"learning-graph-README/#references","title":"References","text":"<ul> <li>Learning Graph Generator: https://github.com/dmccreary/learning-graphs/tree/main/skills/learning-graph-generator</li> <li>Graph Visualization: D3.js, vis.js, Cytoscape.js</li> <li>Bloom's Taxonomy: Knowledge \u2192 Comprehension \u2192 Application \u2192 Analysis \u2192 Synthesis \u2192 Evaluation</li> </ul>"},{"location":"learning-graph-README/#license","title":"License","text":"<p>Same as parent repository: Creative Commons ShareAlike Attribution Noncommercial</p>"},{"location":"license/","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"quality-assessment/","title":"Quality Assessment for FFT Benchmarking Course","text":""},{"location":"quality-assessment/#course-completeness-analysis","title":"Course Completeness Analysis","text":""},{"location":"quality-assessment/#essential-components-present","title":"\u2705 Essential Components Present","text":"<p>Title: Benchmarking FFT \u2713 Course Length: 10 weeks or independent study \u2713 Prerequisites: College juniors/seniors with curiosity in signal processing \u2713 Audience: Clearly defined \u2713 Objectives: Comprehensive Bloom's Taxonomy coverage (Remember \u2192 Create) \u2713 Learning Outcomes: Detailed outcomes across all 6 Bloom levels \u2713</p>"},{"location":"quality-assessment/#content-depth-analysis","title":"Content Depth Analysis","text":"<p>The course description provides an excellent foundation with 52 content topics across multiple domains:</p> <p>Core FFT Topics (15 topics) - Fourier Transforms, Math Foundations, FFT History, Timeline, Basics - FFT Butterfly, FFT and IFFT, Performance, Benchmarking, Parameters - FFT Size, Integer vs Floating Point, Preprocessing, Post-processing, Performance Charts</p> <p>Hardware &amp; Architecture (8 topics) - Programming Background, DSP Functions - Machine Language, Reading Assembly Languages - ARM Cortex-M33, ARM Cortex-M4, Raspberry Pi Pico 2 - Real-time signal processing hardware</p> <p>Software &amp; Tools (12 topics) - Programming Languages, C Language, Python Libraries - FFT Libraries, GitHub Repositories, FFT Licenses - Benchmarking Frameworks, Performance Comparisons - Presenting Results</p> <p>Practical Applications (8 topics) - Real-time FFT implementation - Cornell Labs examples - Windowing techniques, Overlap-add methods - Audio signal processing applications</p>"},{"location":"quality-assessment/#estimated-concept-count","title":"Estimated Concept Count","text":"<p>Based on similar signal processing and embedded systems courses, this course can readily support 200+ concepts:</p> <ul> <li>FFT Algorithms: 35-40 concepts (Cooley-Tukey, radix-2/4/8, butterfly operations, bit-reversal, twiddle factors)</li> <li>DSP Hardware: 30-35 concepts (ARM instructions, SIMD, FPU, memory architecture, DMA)</li> <li>Signal Processing: 30-35 concepts (windowing, overlap-add, zero-padding, frequency bins, sampling theory)</li> <li>Benchmarking Methodology: 25-30 concepts (timing, profiling, statistical analysis, test frameworks)</li> <li>Performance Optimization: 20-25 concepts (cache optimization, loop unrolling, compiler flags, assembly optimization)</li> <li>Mathematical Foundations: 20-25 concepts (complex numbers, DFT, frequency domain, transform properties)</li> <li>Programming &amp; Implementation: 20-25 concepts (C programming, Python numpy/scipy, memory management, fixed-point arithmetic)</li> <li>Applications &amp; Context: 15-20 concepts (audio processing, spectrum analysis, filtering, real-time constraints)</li> </ul> <p>Total Estimated: 195-235 concepts</p>"},{"location":"quality-assessment/#content-gaps-identified","title":"Content Gaps Identified","text":"<p>To reach robust 200-concept coverage, consider expanding:</p> <ol> <li>Memory Management: Cache behavior, DMA setup, buffer management strategies</li> <li>Fixed-Point Arithmetic: Scaling, Q-format, overflow handling, precision analysis</li> <li>Microcontroller Specifics: Clock configuration, peripheral setup, interrupt handling</li> <li>Verification Methods: Test signal generation, accuracy metrics, error analysis</li> <li>Advanced Optimizations: CMSIS-DSP library details, hand-coded assembly, NEON instructions</li> <li>Practical Considerations: Power consumption, thermal constraints, cost analysis</li> </ol>"},{"location":"quality-assessment/#comparison-with-similar-courses","title":"Comparison with Similar Courses","text":"<p>MIT 6.341 Discrete-Time Signal Processing: Similar scope, ~180 concepts Coursera DSP Specialization: 4-course series, ~220 concepts total ARM CMSIS-DSP Training: Hardware focus, ~120 concepts Cornell ECE4760: Practical focus with RP2350, ~90 concepts</p> <p>Conclusion: This course has sufficient depth and breadth for 200 well-structured, interconnected concepts.</p>"},{"location":"quality-assessment/#quality-rating-excellent","title":"Quality Rating: \u2705 EXCELLENT","text":"<p>Rationale: - Complete course structure with all required components - Clear progression from fundamentals to application - Strong grounding in both theory (algorithms, mathematics) and practice (benchmarking, optimization) - Real-world context with affordable hardware (Raspberry Pi Pico 2) - Cornell Labs material provides concrete implementation examples - Bloom's Taxonomy outcomes ensure pedagogical rigor</p> <p>Recommendation: Proceed with generating 200 concept learning graph.</p>"},{"location":"quality-metrics/","title":"Learning Graph Quality Metrics","text":""},{"location":"quality-metrics/#analysis-summary","title":"Analysis Summary","text":"<p>Total Concepts: 200 Analysis Date: 2025-10-30</p>"},{"location":"quality-metrics/#1-dag-validation","title":"1. DAG Validation \u2713","text":"<p>Status: \u2713 PASSED</p> <p>The graph is a valid Directed Acyclic Graph (DAG) with no cycles detected.</p> <p>This ensures: - Concepts have clear prerequisite relationships - No circular dependencies - Linear learning progression is possible - Topological ordering can be computed</p>"},{"location":"quality-metrics/#2-foundational-concepts","title":"2. Foundational Concepts","text":"<p>Count: 10 concepts with zero dependencies</p> <p>These concepts require no prerequisites and serve as entry points:</p> <ol> <li>Complex Numbers</li> <li>Sine Wave Representation</li> <li>ARM Cortex M Series</li> <li>Software Floating Point</li> <li>Fixed Point Numbers</li> <li>Performance Metrics</li> <li>Open Source Libraries</li> <li>Proprietary Libraries</li> <li>GitHub Repositories</li> <li>Compiler Optimization Levels</li> </ol> <p>Analysis: Good distribution of foundational concepts across mathematical, hardware, and software engineering domains.</p>"},{"location":"quality-metrics/#3-indegree-distribution","title":"3. Indegree Distribution","text":"Dependencies Concept Count Percentage 0 10 5.0% 1 153 76.5% 2 35 17.5% 3 2 1.0% <p>Analysis: - Most concepts (76.5%) have exactly one prerequisite - simple linear progression - 17.5% have two prerequisites - reasonable concept convergence - Only 2 concepts have three prerequisites - controlled complexity - Maximum indegree of 3 keeps learning manageable</p>"},{"location":"quality-metrics/#4-longest-dependency-chains","title":"4. Longest Dependency Chains","text":"<p>Top 10 concepts by chain depth:</p> Concept Chain Length Static Linking 7 Dynamic Linking 7 Library Dependencies 7 Mixed Radix FFT 6 Bit Reversal Permutation 6 Power Of Two Constraint 6 Initialization Functions 6 Configuration Parameters 6 Header Files 6 Linking Libraries 6 <p>Analysis: - Maximum chain depth: 7 levels - Advanced topics naturally appear deeper in the dependency tree - Library integration concepts require the most prerequisites - Reasonable depth - not too shallow (would indicate poor structure) nor too deep (would be overwhelming)</p>"},{"location":"quality-metrics/#5-connectivity-analysis","title":"5. Connectivity Analysis","text":"<p>Status: \u26a0 6 disconnected components detected</p> Component Size Description 1 188 Main connected graph (94%) 2-6 12 Small isolated clusters (6%) <p>Interpretation: - Main component contains 94% of concepts - excellent core connectivity - 6% of concepts are in isolated clusters - This is actually pedagogically valid - some topics (e.g., version control, licensing) are independent of core FFT/DSP material - These can be studied in parallel with the main learning path</p> <p>Isolated Concepts: - Likely include: licensing, documentation, version control tools - These support topics don't require technical prerequisites</p>"},{"location":"quality-metrics/#6-graph-statistics","title":"6. Graph Statistics","text":"Metric Value Total Edges (Dependencies) 229 Average Dependencies per Concept 1.15 Graph Density 0.0058 Foundational Concepts 10 Maximum Indegree 3 Maximum Chain Length 7 <p>Interpretation: - Low average dependencies (1.15) - concepts are well-isolated and focused - Low graph density (0.58%) - sparse graph indicates clear learning paths - This is ideal for educational content - not overly interdependent</p>"},{"location":"quality-metrics/#7-pedagogical-assessment","title":"7. Pedagogical Assessment","text":""},{"location":"quality-metrics/#strengths","title":"Strengths \u2713","text":"<ol> <li>Valid DAG structure - no circular dependencies</li> <li>Good foundational base - 10 entry points across domains</li> <li>Manageable complexity - low average dependencies</li> <li>Clear progression - longest chains are 7 levels deep</li> <li>Focused concepts - low graph density suggests well-defined topics</li> <li>Multiple entry points - learners can start with math, hardware, or software</li> </ol>"},{"location":"quality-metrics/#observations","title":"Observations \u26a0","text":"<ol> <li>Minor isolation - 6% of concepts in small disconnected components</li> <li>This is acceptable for support topics like licensing and version control</li> <li>Can be addressed by adding cross-references in documentation</li> </ol>"},{"location":"quality-metrics/#recommendations","title":"Recommendations","text":"<ol> <li>Consider adding lightweight connections between isolated clusters and main graph</li> <li>Use the foundational concepts as course module starting points</li> <li>Organize curriculum to follow the dependency chains</li> <li>Advanced topics (chain length 6-7) should be in later weeks</li> </ol>"},{"location":"quality-metrics/#8-course-structure-recommendations","title":"8. Course Structure Recommendations","text":"<p>Based on the graph structure, suggested 10-week organization:</p> <p>Weeks 1-2: Foundational concepts (10 concepts with zero dependencies) Weeks 3-4: Level 1-2 concepts (mathematical foundations, basic FFT) Weeks 5-6: Level 3-4 concepts (ARM architecture, signal processing) Weeks 7-8: Level 5 concepts (optimization, benchmarking methods) Weeks 9-10: Level 6-7 concepts (advanced library integration, capstone project)</p>"},{"location":"quality-metrics/#overall-quality-rating-excellent","title":"Overall Quality Rating: \u2713 EXCELLENT","text":"<p>The learning graph demonstrates: - Sound pedagogical structure - Clear prerequisite relationships - Appropriate complexity progression - Good balance of breadth and depth - Ready for taxonomy organization and visualization</p>"},{"location":"references/","title":"Site Building References","text":"<ol> <li>mkdocs - https://www.mkdocs.org/ - this is our tool for building the website.  It converts Markdown into HTML in the <code>site</code> directory.</li> <li>mkdocs material theme - https://squidfunk.github.io/mkdocs-material/ - this is the theme for our site.  The theme adds the user interface elements that give our site the look and feel.  It also has the features such as social cards.</li> <li>GitHub Pages - https://pages.github.com/ - this is the free tool for hosting public websites created by mkdocs</li> <li>Markdown - https://www.mkdocs.org/user-guide/writing-your-docs/#writing-with-markdown - this is the format we use for text.  It allows us to have headers, lists, tables, links and images without learning HTML.</li> <li>Deploy Mkdocs GitHub Action - https://github.com/marketplace/actions/deploy-mkdocs - this is the tool we use to automatically build our site after edits are checked in with Git.</li> <li>Git Book - https://git-scm.com/book/en/v2 - a useful book on Git.  Just read the first two chapters to learn how to check in new code.</li> <li>Conda - https://conda.io/ - this is a command line tool that keeps our Python libraries organized for each project.</li> <li>VS Code - https://code.visualstudio.com/ - this is the integrated development environment we use to mange the files on our website.</li> <li>Markdown Paste - https://marketplace.visualstudio.com/items?itemName=telesoho.vscode-markdown-paste-image - this is the VS code extension we use to make sure we keep the markdown format generated by ChatGPT.</li> </ol>"},{"location":"taxonomy-distribution/","title":"Taxonomy distribution","text":"<p>Analyzing taxonomy distribution...</p> <p>====================================================================== TAXONOMY DISTRIBUTION ANALYSIS ======================================================================</p> <p>Total Concepts: 200</p> <p>Distribution by Category: Category | Count | Percentage | Status</p> <p>ARM      |    30 |      15.0% | \u2713 BENCH    |    30 |      15.0% | \u2713 FFT      |    25 |      12.5% | \u2713 SIG      |    25 |      12.5% | \u2713 MEM      |    25 |      12.5% | \u2713 MATH     |    20 |      10.0% | \u2713 LIB      |    20 |      10.0% | \u2713 FXP      |    18 |       9.0% | \u2713 OPT      |     7 |       3.5% | \u2713</p> <p>====================================================================== \u2713 All categories are under 30% threshold - BALANCED</p> <p>Largest category: 15.0% Number of categories: 9 ======================================================================</p>"},{"location":"taxonomy-distribution/#detailed-concept-listing-by-category","title":"Detailed Concept Listing by Category:","text":""},{"location":"taxonomy-distribution/#arm-30-concepts-150","title":"ARM - 30 concepts (15.0%)","text":"<ol> <li>ARM Cortex M Series</li> <li>Cortex M4 Processor</li> <li>Cortex M33 Processor</li> <li>Instruction Set Architecture</li> <li>Thumb Instructions</li> <li>DSP Extension Instructions</li> <li>Single Instruction Multiple Data</li> <li>MAC Instructions</li> <li>Saturating Arithmetic</li> <li>Floating Point Unit</li> <li>Single Precision Float</li> <li>Double Precision Float</li> <li>Hardware Floating Point</li> <li>Software Floating Point</li> <li>FPU Register File</li> <li>Pipeline Architecture</li> <li>Instruction Pipeline</li> <li>Branch Prediction</li> <li>Interrupt Handling</li> <li>Exception Handling</li> <li>Memory Mapped IO</li> <li>Peripheral Access</li> <li>Clock Configuration</li> <li>Clock Cycles</li> <li>Instruction Cycle Count</li> <li>Wait States</li> <li>Flash Memory Access</li> <li>RAM Access Patterns</li> <li>Direct Memory Access</li> <li>DMA Channels</li> </ol>"},{"location":"taxonomy-distribution/#bench-30-concepts-150","title":"BENCH - 30 concepts (15.0%)","text":"<ol> <li>Performance Metrics</li> <li>Execution Time</li> <li>Clock Cycle Measurement</li> <li>System Timer</li> <li>High Resolution Timer</li> <li>Timestamp Counter</li> <li>Profiling Tools</li> <li>Code Profiling</li> <li>Function Profiling</li> <li>Instruction Profiling</li> <li>Statistical Analysis</li> <li>Mean Execution Time</li> <li>Standard Deviation</li> <li>Variance Analysis</li> <li>Outlier Detection</li> <li>Confidence Intervals</li> <li>Benchmark Repeatability</li> <li>Test Case Design</li> <li>Input Signal Generation</li> <li>Sine Wave Test Signal</li> <li>Chirp Signal</li> <li>White Noise Signal</li> <li>Impulse Response</li> <li>Frequency Sweep</li> <li>Amplitude Scaling</li> <li>Baseline Measurement</li> <li>Comparative Analysis</li> <li>Performance Regression</li> <li>Benchmark Automation</li> <li>Test Harness Design</li> </ol>"},{"location":"taxonomy-distribution/#fft-25-concepts-125","title":"FFT - 25 concepts (12.5%)","text":"<ol> <li>Fast Fourier Transform</li> <li>Cooley-Tukey Algorithm</li> <li>Divide And Conquer</li> <li>Butterfly Operation</li> <li>Radix-2 FFT</li> <li>Radix-4 FFT</li> <li>Radix-8 FFT</li> <li>Mixed Radix FFT</li> <li>Decimation In Time</li> <li>Decimation In Frequency</li> <li>Bit Reversal Permutation</li> <li>Twiddle Factors</li> <li>In-Place Computation</li> <li>Computational Complexity</li> <li>FFT Size Selection</li> <li>Power Of Two Constraint</li> <li>Inverse FFT</li> <li>FFT Scaling</li> <li>Real FFT</li> <li>Complex FFT</li> <li>Half-Spectrum Property</li> <li>Zero Padding</li> <li>Frequency Resolution</li> <li>Time Resolution Tradeoff</li> <li>Circular Convolution</li> </ol>"},{"location":"taxonomy-distribution/#sig-25-concepts-125","title":"SIG - 25 concepts (12.5%)","text":"<ol> <li>Digital Signal Processing</li> <li>Analog To Digital Conversion</li> <li>Digital To Analog Conversion</li> <li>Sample Rate</li> <li>Quantization</li> <li>Bit Depth</li> <li>Dynamic Range</li> <li>Signal To Noise Ratio</li> <li>Windowing Functions</li> <li>Rectangular Window</li> <li>Hanning Window</li> <li>Hamming Window</li> <li>Blackman Window</li> <li>Kaiser Window</li> <li>Window Sidelobe Levels</li> <li>Spectral Leakage</li> <li>Scalloping Loss</li> <li>Overlap Add Method</li> <li>Overlap Save Method</li> <li>Frame Size</li> <li>Hop Size</li> <li>Frequency Bins</li> <li>Bin Width</li> <li>Spectrum Analysis</li> <li>Spectrogram</li> </ol>"},{"location":"taxonomy-distribution/#mem-25-concepts-125","title":"MEM - 25 concepts (12.5%)","text":"<ol> <li>Cache Memory</li> <li>Cache Hit Rate</li> <li>Cache Miss Penalty</li> <li>Data Cache</li> <li>Instruction Cache</li> <li>Cache Line Size</li> <li>Memory Alignment</li> <li>Aligned Data Access</li> <li>Unaligned Data Access</li> <li>Memory Bandwidth</li> <li>Memory Latency</li> <li>Stack Memory</li> <li>Heap Memory</li> <li>Static Memory Allocation</li> <li>Dynamic Memory Allocation</li> <li>Buffer Management</li> <li>Double Buffering</li> <li>Ping Pong Buffers</li> <li>Circular Buffers</li> <li>Memory Copy Operations</li> <li>Data Layout</li> <li>Structure Packing</li> <li>Array Of Structures</li> <li>Structure Of Arrays</li> <li>Memory Fragmentation</li> </ol>"},{"location":"taxonomy-distribution/#math-20-concepts-100","title":"MATH - 20 concepts (10.0%)","text":"<pre><code>1. Complex Numbers\n2. Euler's Formula\n3. Sine Wave Representation\n4. Frequency Domain\n5. Time Domain\n6. Discrete Fourier Transform\n7. Continuous Fourier Transform\n8. Transform Pairs\n9. Linearity Property\n</code></pre> <ol> <li>Time Shifting</li> <li>Frequency Shifting</li> <li>Convolution Theorem</li> <li>Parseval's Theorem</li> <li>Symmetry Properties</li> <li>Magnitude Spectrum</li> <li>Phase Spectrum</li> <li>Rectangular Form</li> <li>Polar Form</li> <li>Sampling Theorem</li> <li>Nyquist Frequency</li> </ol>"},{"location":"taxonomy-distribution/#lib-20-concepts-100","title":"LIB - 20 concepts (10.0%)","text":"<ol> <li>CMSIS DSP Library</li> <li>FFTW Library</li> <li>Kiss FFT</li> <li>FFT Library Licensing</li> <li>Open Source Libraries</li> <li>Proprietary Libraries</li> <li>Library API Design</li> <li>Function Call Overhead</li> <li>Initialization Functions</li> <li>Configuration Parameters</li> <li>Library Documentation</li> <li>Example Code</li> <li>GitHub Repositories</li> <li>Version Control</li> <li>Library Integration</li> <li>Header Files</li> <li>Linking Libraries</li> <li>Static Linking</li> <li>Dynamic Linking</li> <li>Library Dependencies</li> </ol>"},{"location":"taxonomy-distribution/#fxp-18-concepts-90","title":"FXP - 18 concepts (9.0%)","text":"<ol> <li>Fixed Point Numbers</li> <li>Q Format Notation</li> <li>Integer Representation</li> <li>Fractional Representation</li> <li>Scaling Factor</li> <li>Fixed Point Multiplication</li> <li>Fixed Point Division</li> <li>Fixed Point Addition</li> <li>Overflow Detection</li> <li>Saturation Handling</li> <li>Rounding Modes</li> <li>Truncation Error</li> <li>Quantization Noise</li> <li>Dynamic Range Management</li> <li>Precision Analysis</li> <li>Bit Width Selection</li> <li>Sign Extension</li> <li>Fixed To Float Conversion</li> </ol>"},{"location":"taxonomy-distribution/#opt-7-concepts-35","title":"OPT - 7 concepts (3.5%)","text":"<ol> <li>Compiler Optimization Levels</li> <li>Loop Unrolling</li> <li>Function Inlining</li> <li>Code Size Optimization</li> <li>Speed Optimization</li> <li>Constant Propagation</li> <li>Dead Code Elimination</li> </ol>"},{"location":"cornell-labs/pico-example/","title":"Cornell University ECE4760","text":"<p>FFT/iFFT testing on the Pi Pico RP2350</p> <p>Quote</p> <p>From this web page: Please explain this text. Assume you are talking to a high-school student. </p> <p>Cornell University ECE4760 FFT/iFFT testing Pi Pico RP2350 Fast Fourier Trnasform and inverse Fast Fourier Transform. Some interesting audio algorithms (e.g. speech compression, effects) work in the frequency domain by doing a FFT on the input signal, fiddling with the frequency components, then transforming back to time domain for output. Since the FFT is a framed computation (works on a stored buffer of input values) you need to be concerned about input-to-output time delay and correctly interpolating from one frame to the next to avoid extremely annoyng artifacts. The approach taken here is to make sure that there is enough information to reasonably interpolate between frames at both the input and output. The steps in the process are: Input samples from ADC at 12.8 Ksamples/sec into a buffer. In the case 512 samples long, which gives 25 FFT frames per second. But with 50% overlap, a new frame starts 50 times/sec. Use a raised cosine window to taper input data to zero at ends of buffer. This is necessary to force periodicity on arbierary input signals. Since the window function goes to zero near both ends, all data is lost there! The windowing means that we need to actually do a FFT on 512 samples, but with only 256 samples separeating the beginning of each transform. This 50% overlap ensures that all data is represented in the FFT output. Do the 512 point FFT with 50% overlap so that no data gets completely lost. Normally here, there would be some sort of filtering, but for this example there is none. We are just verifying that the FFT/iFFT pair reproduces the input. Do iFFT on 512 complex points resulting from the forward FFT. Optionally, window the output of the iFFT (this example does not) before averaging We construct the output buffer by averaging the 50% overlap between iFFTs. This minimizes the inevitable discontinuity between successive transforms. Also, a little thought about data rates will convince you that you need to average the last half of each iFFT output with the first half of the next one to get back to the original sample rate. Construct output buffer of the averaged 50% overlap samples by scaling and offset, Send to DAC at the same rate at the input. The algorithm runs in two parts.: An ISR fills input buffers from the ADC, signals a full input buffer to the thread, and pushes an output buffer to the DAC via SPI. A thread (with a strict time deadline of 256 sample times) runs the windowing, FFT, iFFT, fills an output buffer, and signals the ISR when a new output buffer is ready. There is either a signal generator or microphone attached to ADC channel 2. An SPI channel runs the DAC. VGA output comnections are explained in the code, but the program will run without any VGA connection. Audio examples coming soon. !!!!</p> <p>Here's a high-school-level explanation of that Cornell University ECE4760 description about the Fast Fourier Transform (FFT) on the Raspberry Pi Pico RP2350:</p>"},{"location":"cornell-labs/pico-example/#whats-going-on","title":"\ud83c\udfb5 What's Going On","text":"<p>This project is about how computers can analyze and modify sound --- like music or voices --- using math.</p> <p>When sound enters a microphone, it's a waveform over time (called the time domain). But many cool audio effects (like speech compression, pitch shifting, or equalizers) work better if you look at the sound as a collection of frequencies --- the frequency domain.</p> <p>To switch between these two ways of viewing sound, engineers use special math tools:</p> <ul> <li> <p>FFT (Fast Fourier Transform) \u2192 converts sound from time \u2192 frequency</p> </li> <li> <p>iFFT (inverse FFT) \u2192 converts sound from frequency \u2192 time</p> </li> </ul>"},{"location":"cornell-labs/pico-example/#the-process-step-by-step","title":"\u2699\ufe0f The Process Step-by-Step","text":"<ol> <li> <p>Record sound     The Pi Pico's ADC (analog-to-digital converter) samples the sound 12,800 times per second and stores small chunks (called buffers) of 512 samples each.</p> <ul> <li>This means you get about 25 frames per second of data.</li> </ul> </li> <li> <p>Overlap the frames     To make the sound smooth, the program starts a new frame halfway through the previous one --- this is called 50% overlap.</p> <ul> <li>It helps avoid pops or clicks when frames join together.</li> </ul> </li> <li> <p>Windowing (smoothing the edges)     Before running the FFT, each frame is multiplied by a raised cosine window --- a curve that fades the beginning and end of the data toward zero.</p> <ul> <li> <p>This makes the signal \"look\" more periodic and prevents sharp jumps that cause distortion.</p> </li> <li> <p>The trade-off: some data near the edges is lost, so overlapping frames helps recover it.</p> </li> </ul> </li> <li> <p>FFT and (optionally) modify frequencies     The FFT turns that 512-sample frame into 512 numbers showing how strong each frequency is.</p> <ul> <li>In a real effect, you might change these (boost bass, reduce noise, etc.), but in this lab, they're left unchanged.</li> </ul> </li> <li> <p>iFFT back to sound     The iFFT reverses the process, turning the frequency data back into time-domain samples.</p> </li> <li> <p>Blend overlapping frames     Because of the 50% overlap, the second half of one frame and the first half of the next frame are averaged together.</p> <ul> <li>This blending ensures the playback is smooth and the timing matches the input rate.</li> </ul> </li> <li> <p>Send to speaker     The DAC (digital-to-analog converter) sends the processed signal out at the same speed (12.8 kHz), reproducing the original (or modified) sound.</p> </li> </ol>"},{"location":"cornell-labs/pico-example/#how-the-code-runs","title":"\ud83e\udde0 How the Code Runs","text":"<p>There are two main parts of the program:</p> <ul> <li> <p>ISR (Interrupt Service Routine):     Works like a super-fast helper that grabs microphone data and sends finished output to the DAC.     It quickly fills and empties buffers while the main program thinks.</p> </li> <li> <p>Main Thread:     Runs the FFT, iFFT, and averaging math.     It must finish within the time it takes to collect 256 samples (because of the 50% overlap).     That's a tight deadline --- it tests whether the code is efficient.</p> </li> </ul>"},{"location":"cornell-labs/pico-example/#why-it-matters","title":"\ud83e\udde9 Why It Matters","text":"<p>This lab shows how real-time digital audio works on a tiny computer. It teaches key engineering ideas like:</p> <ul> <li> <p>Sampling and data rates</p> </li> <li> <p>Buffering and frame overlap</p> </li> <li> <p>Frequency-domain processing</p> </li> <li> <p>Synchronizing input and output</p> </li> </ul> <p>Once you understand this, you can build effects like:</p> <ul> <li> <p>Echo, pitch-shift, auto-tune</p> </li> <li> <p>Noise cancellation</p> </li> <li> <p>Equalizers (like the bass &amp; treble MicroSim you uploaded)</p> </li> </ul>"}]}